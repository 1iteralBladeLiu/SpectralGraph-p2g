[
  {
    "objectID": "prototype_book.html",
    "href": "prototype_book.html",
    "title": "Spectral Graphs & Poly2Graph — A Hands‑On Tutorial",
    "section": "",
    "text": "By the end of this tutorial, you will be able to:\n\nExplain what a spectral graph is (a graph traced by the energy spectrum of a 1‑D crystal on the complex plane under open boundaries).\nUnderstand the key mathematical objects that appear in modern treatments: the characteristic polynomial \\(P(z,E)\\), the spectral potential \\(\\Phi(E)\\), and the density of states \\(\\rho(E)\\).\nDescribe prior pain points (manual inspection, numerical bottlenecks, fragile extraction) and the need for an automated tool.\nUse Poly2Graph to go from a symbolic Hamiltonian/characteristic polynomial to its spectral graph, and analyze/visualize the result."
  },
  {
    "objectID": "prototype_book.html#learning-objectives",
    "href": "prototype_book.html#learning-objectives",
    "title": "Spectral Graphs & Poly2Graph — A Hands‑On Tutorial",
    "section": "",
    "text": "By the end of this tutorial, you will be able to:\n\nExplain what a spectral graph is (a graph traced by the energy spectrum of a 1‑D crystal on the complex plane under open boundaries).\nUnderstand the key mathematical objects that appear in modern treatments: the characteristic polynomial \\(P(z,E)\\), the spectral potential \\(\\Phi(E)\\), and the density of states \\(\\rho(E)\\).\nDescribe prior pain points (manual inspection, numerical bottlenecks, fragile extraction) and the need for an automated tool.\nUse Poly2Graph to go from a symbolic Hamiltonian/characteristic polynomial to its spectral graph, and analyze/visualize the result."
  },
  {
    "objectID": "prototype_book.html#what-is-a-spectral-graph-and-why-is-it-interesting",
    "href": "prototype_book.html#what-is-a-spectral-graph-and-why-is-it-interesting",
    "title": "Spectral Graphs & Poly2Graph — A Hands‑On Tutorial",
    "section": "0.2 What is a spectral graph (and why is it interesting)?",
    "text": "0.2 What is a spectral graph (and why is it interesting)?\nBasic idea :\nConsider a simple 1‑D crystal (a line of repeating “cells”). Its energy levels \\(E\\) depend on a wavelike parameter \\(k\\) (momentum).\nUnder periodic boundaries (“a loop”), energies trace closed loops as \\(k\\) runs from \\(0\\) to \\(2\\pi\\).\nUnder open boundaries (“a finite chain”), something shocking can happen in non‑Hermitian systems (with loss/gain or non‑reciprocal couplings): the eigen‑energies collapse into arcs and loops drawn directly on the complex \\(E\\)‑plane. Connect those arcs/loops and you get a spectral graph.\nA few key notions :\n\nThe physics lives in the characteristic polynomial of the Bloch Hamiltonian \\(H(z)\\):\n\\(P(z,E)=\\det[H(z)-E I] = \\sum_{n=-p}^q a_n(E)\\,z^n,\n\\quad z=e^{ik}\\)\nSort the \\(z\\)‑roots \\(\\beta_i(E)\\) of \\(P(z,E)=0\\) by magnitude. On the spectral graph, the “middle two” obey \\(|\\beta_p(E)|=|\\beta_{p+1}(E)|\\). This condition defines the generalized Brillouin zone (GBZ) and pins down the spectral loci under OBC.\nDefine a spectral potential (a Ronkin function) from the roots (one convenient form):\n\\(\\Phi(E) = - \\log|a_q(E)| - \\sum_{i=p+1}^{p+q}\\log|\\beta_i(E)|\\) Its Laplacian gives the density of states (DOS):\n\\(\\rho(E)= -\\tfrac{1}{2\\pi}\\nabla^2\\Phi(E)\\)\n\nIntuition: treat each eigenvalue \\(\\epsilon_n\\) as a tiny electric charge \\(\\rho(E) = \\lim_{N\\to\\infty}\\sum_n \\frac{1}{N} \\delta(E-\\epsilon_n)\\); while \\(\\Phi(E)\\) is an electrostatic‑like potential whose “ridges/troughs” trace the spectral graph; \\(\\rho(E)\\) is nonzero only on the graph. Please see the Section 1.0.1 below for a concrete illustration.\nWhy interesting?\nNon‑Hermitian spectra can realize many more graph connectivities than standard topological labels (like \\(\\mathbb{Z},\\mathbb{Z}_2\\)): stars, flowers, braids, etc., with novel transitions that change the number of endpoints/junctions/loops (no Hermitian analog). This is naturally expressed by writing dispersions as bivariate Laurent polynomials \\(P(E,z)\\) and studying how their imaginary‑momentum (“inverse skin depth”) surfaces intersect across the \\(E\\)‑plane.\nMoreover, spectral graph is a general algebra-to-graph bridge. Because the equation \\(\\Phi(E) = - \\log|a_q(E)| - \\sum_{i=p+1}^{p+q}\\log|\\beta_i(E)|\\) uses only \\(P(E,z)\\), the construction extends to arbitrary Laurent polynomials, and via standard reductions to vectors and matrices. You get a universal topological fingerprint for many algebraic objects—making graph learning a front-door to problems in linear algebra, signal processing, photonics, circuits, and more.\nHere, we visualize a single-band example by an interactive 3D surface plot of \\(\\Phi(E)\\) along with the extracted skeleton Figure 1.\n\n0.2.1 Session 2"
  },
  {
    "objectID": "prototype_book.html#what-was-hard-before-and-why-we-need-poly2graph",
    "href": "prototype_book.html#what-was-hard-before-and-why-we-need-poly2graph",
    "title": "Spectral Graphs & Poly2Graph — A Hands‑On Tutorial",
    "section": "0.3 What was hard before (and why we need Poly2Graph)?",
    "text": "0.3 What was hard before (and why we need Poly2Graph)?\nPrior to Poly2Graph, extracting spectral graphs was manual and fragile: - You had to scan parameters, plot large finite‑chain spectra, and visually infer the continuum graph. - Computing the GBZ roots \\(\\beta_i(E)\\) for every sampled energy \\(E\\) is a bottleneck; naive solvers are slow and memory‑hungry. - Even with a DOS image, turning that into a clean graph with correct endpoints, junctions, and loops requires careful morphology (thresholding, skeletonization, node/edge parsing).\nPoly2Graph lifts these barriers with an end‑to‑end, high‑performance pipeline: 1. Accepts either \\(H(z)\\) (as a sympy.Matrix) or \\(P(z,E)\\) (string or sympy.Poly).\n2. Computes the spectral potential \\(\\Phi(E)\\) from \\(z\\)‑roots (fast eigen‑solvers on Frobenius companion matrices; optional GPU/TPU via TensorFlow/PyTorch).\n3. Takes the Laplacian to get DOS, then does adaptive, two‑stage refinement (coarse mask → high‑res on just ~1–5% of the region).\n4. Applies image morphology to extract a one‑pixel skeleton, then returns a NetworkX MultiGraph with full edge geometry (the sampled curve).\nThis automation has enabled HSG‑12M (11.6M static + 5.1M temporal spectral multigraphs), demonstrating scale and diversity previously out of reach(Learn more from @arXiv:2506.08618 if interested).\nNow let’s try to use Poly2Graph ***\n\n# If running on devices without essential libraries, uncomment the next line:\n# !pip install -U poly2graph sympy networkx matplotlib\n\nimport sympy as sp\nimport numpy as np\nnp.set_printoptions(threshold=20)\nimport matplotlib.pyplot as plt\nimport matplotlib.colors as colors\nimport networkx as nx\n\n# Poly2Graph (must be installed in your environment)\n# If this import fails, run the pip command above.\nimport poly2graph as p2g\n\n\n# For better plotly rendering in Jupyter environments\nimport plotly.io as pio\npio.renderers.default = \"plotly_mimetype+notebook_connected\"\n\nPlease ensure your version of Python &gt;= 3.11 , you can check the installation:\n\nprint(\"Poly2Graph version:\", p2g.__version__)\n\nPoly2Graph version: 0.2.0\n\n\n\n# Always remember to define common symbols first\nk = sp.symbols('k', real=True)\nz, E = sp.symbols('z E', complex=True)\n\n\n0.3.1 1. Quick start"
  },
  {
    "objectID": "prototype_book.html#oneband-example",
    "href": "prototype_book.html#oneband-example",
    "title": "Spectral Graphs & Poly2Graph — A Hands‑On Tutorial",
    "section": "0.4 one‑band example",
    "text": "0.4 one‑band example\nWe’ll start from a simple one‑band characteristic polynomial and obtain its spectral graph.\nCharacteristic polynomial $ P(z,E) = z^4 - z^2 - z^{-1} - E $ (This corresponds to a scalar Bloch Hamiltonian \\(h(z)=z^4-z^2-z^{-1}\\), with \\(z=e^{ik}\\).)\nThe valid input formats to initialize a p2g.SpectralGraph object are: 1. Characteristic polynomial in terms of z and E: - as a string of the Poly in terms of z and E - as a sympy’s Poly (sympy.polys.polytools.Poly) with {z, 1/z, E} as generators 2. Bloch Hamiltonian in terms of k or z - as a sympy Matrix in terms of k - as a sympy Matrix in terms of z\nAll the following characteristics are valid and will initialize to the same characteristic polynomial and therefore produce the same spectral graph\n\nchar_poly_str = '-z**-1 - E - z**2 + z**4'\n\nchar_poly_Poly = sp.Poly(\n    -z**-1 - E - z**2 + z**4,\n    z, 1/z, E # generators are z, 1/z, E\n)\n\nphase_k = sp.exp(sp.I*k)\nchar_hamil_k = sp.Matrix([-phase_k**-1 - phase_k**2 + phase_k**4])\n\nchar_hamil_z = sp.Matrix([-z**-1 - E - z**2 + z**4])\n\nHere we use the string format as the initialization example.\n\nsg = p2g.SpectralGraph(char_poly_str, k=k, z=z, E=E)\n\n\n# print the number of energy bands\nprint('Bands:', sg.num_bands)\n\n# print the max hopping range (p,q)\nprint('Max hop (right):', sg.poly_p, 'Max hop (left):', sg.poly_q)\n\n# print the [Ereal_min,Ereal_max,Eimag_min,Eimag_max] window\nprint('Spectral window (auto-estimated):', sg.spectral_square) \n\nBands: 1\nMax hop (right): 1 Max hop (left): 4\nSpectral window (auto-estimated): [-2.31139048  1.6398687  -1.97562959  1.97562959]\n\n\nWe will see Poly2Graph automatically compute set of properties next:\n\nsg.ChP\n\n\\(\\displaystyle \\operatorname{Poly}{\\left( z^{4} - z^{2} - \\frac{1}{z} - E, z, \\frac{1}{z}, E, domain=\\mathbb{Z} \\right)}\\)\n\n\nBloch Hamiltonian:\n\nFor one-band model(The exponent of \\(E\\) is 1), it is a unique, rank-0 matrix (scalar)\n\n\nsg.h_k\n\n\\(\\displaystyle \\left[\\begin{matrix}e^{4 i k} - e^{2 i k} - e^{- i k}\\end{matrix}\\right]\\)\n\n\nor in \\(z\\) format(recall that \\(z = e^{ik}\\))\n\nsg.h_z\n\n\\(\\displaystyle \\left[\\begin{matrix}- \\frac{- z^{5} + z^{3} + 1}{z}\\end{matrix}\\right]\\)\n\n\nFrobenius Companion Matrix of \\(P(z, E)\\):\n\nThe Frobenius companion matrix is a special matrix whose eigenvalues are exactly the roots of the characteristic polynomial \\(P(z, E)\\) for fixed \\(E\\).\nIn Poly2Graph, sg.companion_E gives this matrix (with \\(E\\) as a parameter, \\(z\\) as variable).\nPurpose:\n\nEfficiently computes all \\(z\\)-roots for any \\(E\\) using linear algebra (eigenvalues), instead of slow root-finding.\nThese \\(z\\)-roots are essential for calculating the spectral graph, GBZ, spectral potential, and density of states.\n\n\n\nsg.companion_E\n\n\\(\\displaystyle \\left[\\begin{matrix}0 & 0 & 0 & 0 & 1\\\\1 & 0 & 0 & 0 & E\\\\0 & 1 & 0 & 0 & 0\\\\0 & 0 & 1 & 0 & 1\\\\0 & 0 & 0 & 1 & 0\\end{matrix}\\right]\\)\n\n\nIt is a key tool for automating and accelerating spectral graph extraction in Poly2Graph.\n\n0.4.1 Spectral potential \\(\\Phi(E)\\), density of states \\(\\rho(E)\\), and skeleton\nWe compute \\(\\Phi(E)\\) and \\(\\rho(E)\\) on a grid of complex energies, then binarize \\(\\rho(E)\\) to get a skeleton.\n::: {#cell-1 band spectral images .cell execution_count=12}\nphi, dos, skel = sg.spectral_images()\n\nfig, axes = plt.subplots(1, 3, figsize=(8, 3), sharex=True, sharey=True)\n\n# 1) Spectral potential\naxes[0].imshow(phi, extent=sg.spectral_square, origin='lower', cmap='terrain')\naxes[0].set(xlabel='Re(E)', ylabel='Im(E)', title='Spectral Potential')\n\n# 2) Density of States\npmin, pmax = np.percentile(dos, (0.1, 99.9))\n# Clip extreme DOS to increase visibility\nnorm = colors.Normalize(vmin=pmin, vmax=pmax)\naxes[1].imshow(dos, extent=sg.spectral_square, cmap='viridis', norm=norm)\naxes[1].set(xlabel='Re(E)', title='Density of States')\n\n# 3) Binarized skeleton\naxes[2].imshow(skel, extent=sg.spectral_square, cmap='gray')\naxes[2].set(xlabel='Re(E)', title='Graph Skeleton')\nplt.tight_layout()\nplt.savefig(\"assets/1-band-example_si.png\")\nplt.show()\n\n\n\n\nSpectral images for 1 band example: (1) Spectral potential Φ, (2) Density of States ρ, (3) Graph skeleton from ρ\n\n\n\n:::\n\n\n0.4.2 Extract the spectral graph\nNext, we visualize these results by a interactive 3D surface plot of \\(\\Phi(E)\\) along with the extracted skeleton.\n\nimport plotly.graph_objects as go\n\nE_re = np.linspace(*sg.spectral_square[:2], phi.shape[0])\nE_im = np.linspace(*sg.spectral_square[2:], phi.shape[1])\nfig = go.Figure(data=[go.Surface(z=phi, x=E_re, y=E_im, \n            opacity=0.6, colorscale='Spectral_r')])\nfig.update_layout(\nscene=dict(\n    aspectratio=dict(x=1.5, y=1, z=.8),\n    xaxis_title='Re(E)',yaxis_title='Im(E)',zaxis_title='Phi(E)',\n),\ntitle='3D Surface Plot of Spectral Potential',\nwidth=700, height=600\n)\nfig.show()\n\n\n\n                            \n                                            \n\n\nFigure 1: 3D surface plot\n\n\n\n\nsg.spectral_graph() returns a NetworkX MultiGraph with node positions and polyline geometry along each edge.\n::: {#cell-1 band spectral graph .cell execution_count=14}\n# Draw the multi-band spectral graph\nG = sg.spectral_graph()\npos2 = nx.get_node_attributes(G, 'pos')\nplt.figure()\nnx.draw_networkx_nodes(G, pos2, node_size=20)\nnx.draw_networkx_edges(G, pos2)\nplt.axis('equal'); plt.title('Spectral Graph (1-band)')\nplt.show()\n\nprint(f'#nodes: {G.number_of_nodes()}  #edges: {G.number_of_edges()}')\n\n# Show attributes of a node and an edge\nany_node = list(G.nodes(data=True))[0]\nprint('A node has attributes:', list(any_node[1].keys()))\nany_edge = list(G.edges(keys=True, data=True))[0]\nprint('An edge has attributes:', list(any_edge[3].keys()))\n\n\n\n\nSpectral Graph (1-band)\n\n\n\n\n#nodes: 7  #edges: 6\nA node has attributes: ['pos', 'dos', 'potential']\nAn edge has attributes: ['weight', 'pts', 'avg_dos', 'avg_potential']\n\n:::\nAs you can see above, the spectral graph is a networkx.MultiGraph object.\n\nNode Attributes\n\npos : (2,)-numpy array\n\nthe position of the node \\((\\text{Re}(E), \\text{Im}(E))\\)\n\ndos : float\n\nthe density of states at the node\n\npotential : float\n\nthe spectral potential at the node\n\n\nEdge Attributes\n\nweight : float\n\nthe weight of the edge, which is the length of the edge in the complex energy plane\n\npts : (w, 2)-numpy array\n\nthe positions of the points constituting the edge, where w is the number of points along the edge, i.e., the length of the edge, equals weight\n\navg_dos : float\n\nthe average density of states along the edge\n\navg_potential : float\n\nthe average spectral potential along the edge\n\n\n\n\nnode_attr = dict(G.nodes(data=True))\nedge_attr = list(G.edges(data=True))\nprint('The attributes of the first node\\n', node_attr[0], '\\n')\nprint('The attributes of the first edge\\n', edge_attr[0][-1], '\\n')\n\nThe attributes of the first node\n {'pos': array([0.88936098, 1.90810319]), 'dos': np.float32(0.25110298), 'potential': np.float32(-0.4699422)} \n\nThe attributes of the first edge\n {'weight': np.float64(2.0950480742544872), 'pts': array([[0.88550233, 1.89652723],\n       [0.88550233, 1.89266858],\n       [0.88550233, 1.88880993],\n       ...,\n       [0.81990525, 0.01350528],\n       [0.8237639 , 0.00964663],\n       [0.8237639 , 0.00192933]]), 'avg_dos': np.float32(0.079228334), 'avg_potential': np.float32(-0.2639912)} \n\n\n\n\n\n0.4.3 2. Multi‑band example"
  },
  {
    "objectID": "prototype_book.html#multiband-example",
    "href": "prototype_book.html#multiband-example",
    "title": "Spectral Graphs & Poly2Graph — A Hands‑On Tutorial",
    "section": "0.5 Multi‑band example",
    "text": "0.5 Multi‑band example\nNow consider a four‑band polynomial:\n\\[\nP(z,E) = z^2 + z^{-2} + E z - E^4\n\\]\nA possible Bloch Hamiltonian realization is: \\[\\textbf{h}(z)=\\begin{pmatrix}\n0 & 0 & 0 & z^2 + 1/z^2 \\\\\n1 & 0 & 0 & z \\\\\n0 & 1 & 0 & 0 \\\\\n0 & 0 & 1 & 0 \\\\\n\\end{pmatrix}\\] Poly2Graph can work directly from the string/sympy.Poly as shown below.\n\n# We start with a polynomial string\nsg_multi = p2g.SpectralGraph(\"z**2 + 1/z**2 + E*z - E**4\", k, z, E)\n\n\n# print the number of energy bands\nprint('Bands:', sg_multi.num_bands)\n\n# print the max hopping range (p,q)\nprint('Max hop (right):', sg_multi.poly_p, 'Max hop (left):', sg_multi.poly_q)\n\n# print the [Ereal_min,Ereal_max,Eimag_min,Eimag_max] window\nprint('Spectral window (auto-estimated):', sg_multi.spectral_square)\n\nBands: 4\nMax hop (right): 2 Max hop (left): 2\nSpectral window (auto-estimated): [-1.40559546  1.40559546 -1.40559546  1.40559546]\n\n\n\nsg_multi.ChP\n\n\\(\\displaystyle \\operatorname{Poly}{\\left( z^{2} + zE + \\frac{1}{z^{2}} - E^{4}, z, \\frac{1}{z}, E, domain=\\mathbb{Z} \\right)}\\)\n\n\n\nsg_multi.h_k\n\n\\(\\displaystyle \\left[\\begin{matrix}0 & 0 & 0 & e^{2 i k} + e^{- 2 i k}\\\\1 & 0 & 0 & e^{i k}\\\\0 & 1 & 0 & 0\\\\0 & 0 & 1 & 0\\end{matrix}\\right]\\)\n\n\n\nsg_multi.h_z\n\n\\(\\displaystyle \\left[\\begin{matrix}0 & 0 & 0 & z^{2} + \\frac{1}{z^{2}}\\\\1 & 0 & 0 & z\\\\0 & 1 & 0 & 0\\\\0 & 0 & 1 & 0\\end{matrix}\\right]\\)\n\n\n\nsg_multi.companion_E\n\n\\(\\displaystyle \\left[\\begin{matrix}0 & 0 & 0 & -1\\\\1 & 0 & 0 & 0\\\\0 & 1 & 0 & E^{4}\\\\0 & 0 & 1 & - E\\end{matrix}\\right]\\)\n\n\n\n0.5.1 Spectral potential \\(\\Phi(E)\\), density of states \\(\\rho(E)\\), and skeleton\nLike the one-band example, we also compute \\(\\Phi(E)\\) and \\(\\rho(E)\\) on a grid of complex energies, then binarize \\(\\rho(E)\\) to get a skeleton.\n::: {#cell-Multi-band spectral images .cell execution_count=22}\nphi2, dos2, skel2 = sg_multi.spectral_images()\n\nfig, axes = plt.subplots(1, 3, figsize=(8, 3), sharex=True, sharey=True)\n\n# 1) Spectral potential\naxes[0].imshow(phi2, extent=sg.spectral_square, origin='lower', cmap='terrain')\naxes[0].set(xlabel='Re(E)', ylabel='Im(E)', title='Spectral Potential')\n\n# 2) Density of States\npmin, pmax = np.percentile(dos, (0.1, 99.9))\n# Clip extreme DOS to increase visibility\nnorm = colors.Normalize(vmin=pmin, vmax=pmax)\naxes[1].imshow(dos2, extent=sg.spectral_square, cmap='viridis', norm=norm)\naxes[1].set(xlabel='Re(E)', title='Density of States')\n\n# 3) Binarized skeleton\naxes[2].imshow(skel2, extent=sg.spectral_square, cmap='gray')\naxes[2].set(xlabel='Re(E)', title='Graph Skeleton')\nplt.tight_layout()\nplt.savefig(\"assets/multi-band-example_si.png\")\nplt.show()\n\n\n\n\nSpectral images for multi-band example: (1) Spectral potential Φ, (2) Density of States ρ, (3) Graph skeleton from ρ\n\n\n\n:::\n\n\n0.5.2 Extract the spectral graph\n::: {#cell-Multi-band spectral graph .cell execution_count=23}\n# Draw the multi-band spectral graph\nG2 = sg_multi.spectral_graph()\npos2 = nx.get_node_attributes(G2, 'pos')\nplt.figure()\nnx.draw_networkx_nodes(G2, pos2, node_size=20)\nnx.draw_networkx_edges(G2, pos2)\nplt.axis('equal'); plt.title('Spectral Graph (multi‑band)')\nplt.show()\n\nprint(f'#nodes: {G2.number_of_nodes()}  #edges: {G2.number_of_edges()}')\n\n# Show attributes of a node and an edge\nany_node = list(G2.nodes(data=True))[0]\nprint('A node has attributes:', list(any_node[1].keys()))\nany_edge = list(G2.edges(keys=True, data=True))[0]\nprint('An edge has attributes:', list(any_edge[3].keys()))\n\n\n\n\nSpectral Graph (multi‑band)\n\n\n\n\n#nodes: 21  #edges: 18\nA node has attributes: ['pos', 'dos', 'potential']\nAn edge has attributes: ['weight', 'pts', 'avg_dos', 'avg_potential']\n\n:::\n\n\n0.5.3 3. Characteristic Polynomial Class"
  },
  {
    "objectID": "prototype_book.html#p2g.charpolyclass",
    "href": "prototype_book.html#p2g.charpolyclass",
    "title": "Spectral Graphs & Poly2Graph — A Hands‑On Tutorial",
    "section": "0.6 p2g.CharPolyClass",
    "text": "0.6 p2g.CharPolyClass\nFor scanning families of polynomials (e.g., varying two complex coefficients across a grid), use p2g.CharPolyClass. This class parallelizes evaluation and is designed to generate many graphs efficiently (e.g., to reproduce temporal sequences as in T‑HSG‑5M).\nTo be specific, p2g.CharPolyClass is: - A class of parametrized non-Hermitian lattices - Generate spectral properties, including spectral graph in parallel - Optimized for computational efficiency and numerical stability\nLet us add two parameters {a,b} to the aforementioned multi-band example and construct a p2g.CharPolyClass object.\n\na, b = sp.symbols('a b', real=True)\n\ncp = p2g.CharPolyClass(\n    \"z**2 + a/z**2 + b*E*z - E**4\", \n    k=k, z=z, E=E,\n    params={a, b}, # pass parameters as a set\n)\n\nDerived Bloch Hamiltonian `h_z` with 4 bands.\n\n\nJust like the examples above, we can also check the automatically computed properties:\n\ncp.ChP\n\n\\(\\displaystyle \\operatorname{Poly}{\\left( z^{2} + b zE + a \\frac{1}{z^{2}} - E^{4}, z, \\frac{1}{z}, E, domain=\\mathbb{Z}\\left[a, b\\right] \\right)}\\)\n\n\n\ncp.h_k\n\n\\(\\displaystyle \\left[\\begin{matrix}0 & 0 & 0 & a e^{- 2 i k} + e^{2 i k}\\\\1 & 0 & 0 & b e^{i k}\\\\0 & 1 & 0 & 0\\\\0 & 0 & 1 & 0\\end{matrix}\\right]\\)\n\n\n\ncp.h_z\n\n\\(\\displaystyle \\left[\\begin{matrix}0 & 0 & 0 & \\frac{a}{z^{2}} + z^{2}\\\\1 & 0 & 0 & b z\\\\0 & 1 & 0 & 0\\\\0 & 0 & 1 & 0\\end{matrix}\\right]\\)\n\n\n\ncp.companion_E\n\n\\(\\displaystyle \\left[\\begin{matrix}0 & 0 & 0 & - a\\\\1 & 0 & 0 & 0\\\\0 & 1 & 0 & E^{4}\\\\0 & 0 & 1 & - E b\\end{matrix}\\right]\\)\n\n\nTo get an array of spectral images or spectral graphs, we first prepare the values of the parameters {a,b}\n\na_array = np.linspace(-2, 2, 6)\nb_array = np.linspace(-1, 1, 6)\na_grid, b_grid = np.meshgrid(a_array, b_array)\nparam_dict = {a: a_grid, b: b_grid}\nprint('a_grid shape:', a_grid.shape,\n    '\\nb_grid shape:', b_grid.shape)\n\na_grid shape: (6, 6) \nb_grid shape: (6, 6)\n\n\nYou can check the grid generated to ensure your parameters\n\na_grid, b_grid\n\n(array([[-2. , -1.2, -0.4,  0.4,  1.2,  2. ],\n        [-2. , -1.2, -0.4,  0.4,  1.2,  2. ],\n        [-2. , -1.2, -0.4,  0.4,  1.2,  2. ],\n        [-2. , -1.2, -0.4,  0.4,  1.2,  2. ],\n        [-2. , -1.2, -0.4,  0.4,  1.2,  2. ],\n        [-2. , -1.2, -0.4,  0.4,  1.2,  2. ]]),\n array([[-1. , -1. , -1. , -1. , -1. , -1. ],\n        [-0.6, -0.6, -0.6, -0.6, -0.6, -0.6],\n        [-0.2, -0.2, -0.2, -0.2, -0.2, -0.2],\n        [ 0.2,  0.2,  0.2,  0.2,  0.2,  0.2],\n        [ 0.6,  0.6,  0.6,  0.6,  0.6,  0.6],\n        [ 1. ,  1. ,  1. ,  1. ,  1. ,  1. ]]))\n\n\nNote that the value array of the parameters should have the same shape, which is also the shape of the output array of spectral images\n\nphi_arr, dos_arr, binaried_dos_arr, spectral_square = \\\n    cp.spectral_images(param_dict=param_dict, device='/cpu:0')\nprint('phi_arr shape:', phi_arr.shape,\n    '\\ndos_arr shape:', dos_arr.shape,\n    '\\nbinaried_dos_arr shape:', binaried_dos_arr.shape)\n\nphi_arr shape: (6, 6, 1024, 1024) \ndos_arr shape: (6, 6, 1024, 1024) \nbinaried_dos_arr shape: (6, 6, 1024, 1024)\n\n\n\nphi_arr[:, :, 0, 0]\n\narray([[-2.79088283, -2.56152201, -2.07190657, -2.33312154, -2.826159  ,\n        -3.05699062],\n       [-2.61931658, -2.3819747 , -1.87466085, -2.14679098, -2.65622234,\n        -2.89444447],\n       [-2.42141795, -2.17299414, -1.64018846, -1.92253423, -2.45588088,\n        -2.70452452],\n       [-2.42141819, -2.17299461, -1.64018691, -1.92253542, -2.45588088,\n        -2.70452452],\n       [-2.61931658, -2.3819747 , -1.87466145, -2.14679122, -2.65622234,\n        -2.8944447 ],\n       [-2.79088283, -2.56152201, -2.07190657, -2.33312154, -2.82615995,\n        -3.05699062]])\n\n\nphi_arr, dos_arr, and binaried_dos_arr are arrays computed by cp.spectral_images(), representing different spectral quantities:\n\nphi_arr: The array of spectral potential values, i.e., \\(\\Phi(E)\\), for each parameter point((a,b), here \\(6*6\\)) and energy grid(each small sampling grid on the complex \\(E\\) plain, here \\(1024*1024\\)). It describes the “potential landscape” over the complex energy plane, with its ridges tracing the spectral graph.\ndos_arr: The array of density of states values, i.e., \\(\\rho(E)\\), for each parameter point and energy grid. It is significant only on the spectral graph (where the spectral condition is met), and nearly zero elsewhere.\nbinaried_dos_arr: The binarized density of states array, obtained by thresholding \\(\\rho(E)\\), which extracts the skeleton (the graph structure) for further analysis.\n\nThese arrays typically have shapes like (number of parameter points, ..., H, W), where \\(H\\) and \\(W\\) are the height and width of the energy grid. Each parameter point corresponds to one spectral potential/density/skeleton image.\n::: {#cell-ChP spectral images .cell execution_count=33}\nfrom mpl_toolkits.axes_grid1 import ImageGrid\n\nfig = plt.figure(figsize=(13, 13))\ngrid = ImageGrid(fig, 111, nrows_ncols=(6, 6), axes_pad=0, \n                 label_mode='L', share_all=True)\n\nfor ax, (i, j) in zip(grid, [(i, j) for i in range(6) for j in range(6)]):\n    ax.imshow(phi_arr[i, j], extent=spectral_square[i, j], cmap='Spectral_r')\n    ax.set(xlabel='Re(E)', ylabel='Im(E)')\n    ax.text(\n        0.03, 0.97, f'a = {a_array[i]:.2f}, b = {b_array[j]:.2f}',\n        ha='left', va='top', transform=ax.transAxes,\n        fontsize=10, color='tab:red',\n        bbox=dict(alpha=0.8, facecolor='white')\n    )\n\nplt.tight_layout()\nplt.savefig(\"assets/ChP-example_si.png\")\nplt.show()\n\nC:\\Users\\ReYangonLiu\\AppData\\Local\\Temp\\ipykernel_6764\\1050636169.py:20: UserWarning:\n\nThis figure includes Axes that are not compatible with tight_layout, so results might be incorrect.\n\n\n\n\n\n\na & b parameter grid of spectral potential Φ(E)\n\n\n\n:::\n\n0.6.1 *Example: {#sec-gallery-example}"
  }
]