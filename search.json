[
  {
    "objectID": "prototype_book.html",
    "href": "prototype_book.html",
    "title": "Spectral Graphs & Poly2Graph — A Hands‑On Tutorial",
    "section": "",
    "text": "This tutorial is for the ones don’t have physics background, introducing the concepts of spectral graphs and demonstrates how to use the Poly2Graph library to create and manipulate spectral graphs in Python.\nTo fully benefit from this tutorial, you should have a basic understanding of Python programming and mathematical background on polynomials and complex functions."
  },
  {
    "objectID": "prototype_book.html#introduction",
    "href": "prototype_book.html#introduction",
    "title": "Spectral Graphs & Poly2Graph — A Hands‑On Tutorial",
    "section": "",
    "text": "This tutorial is for the ones don’t have physics background, introducing the concepts of spectral graphs and demonstrates how to use the Poly2Graph library to create and manipulate spectral graphs in Python.\nTo fully benefit from this tutorial, you should have a basic understanding of Python programming and mathematical background on polynomials and complex functions."
  },
  {
    "objectID": "prototype_book.html#learning-objectives",
    "href": "prototype_book.html#learning-objectives",
    "title": "Spectral Graphs & Poly2Graph — A Hands‑On Tutorial",
    "section": "2 Learning objectives",
    "text": "2 Learning objectives\nBy the end of this tutorial, you will be able to:\n\nExplain what a spectral graph is (a graph traced by the energy spectrum of a 1‑D crystal on the complex plane under open boundaries).\nUnderstand the key mathematical objects that appear in modern treatments: the characteristic polynomial \\(P(z,E)\\), the spectral potential \\(\\Phi(E)\\), and the density of states \\(\\rho(E)\\).\nDescribe prior pain points (manual inspection, numerical bottlenecks, fragile extraction) and the need for an automated tool.\nUse Poly2Graph to go from a symbolic Hamiltonian/characteristic polynomial to its spectral graph, and analyze/visualize the result.\n\n\n  Figure 1. Concept map \n\nThe Figure 1 shows the concept map of this tutorial, (a) starting from 1-D crystal Hamiltonian \\(H(z)\\) in momentum space, or its equivalent characteristic polynomial \\(P(z,E) = z^2 + 1/z^2 + 10Ez - E^4\\), (b) calculating the spectral potential \\(\\Phi(E)\\)(Rokin Function) through the roots of \\(P(z,E) = 0\\), (c) the density of states \\(\\rho(E)\\), obtained as the Laplacian of \\(\\Phi(E)\\) and (d) visualizing the spectral graph through sg.spectral_graph() based on NetWorkX."
  },
  {
    "objectID": "prototype_book.html#sec-what-is-spectral-graph",
    "href": "prototype_book.html#sec-what-is-spectral-graph",
    "title": "Spectral Graphs & Poly2Graph — A Hands‑On Tutorial",
    "section": "3 What is a spectral graph?",
    "text": "3 What is a spectral graph?\nConsider a simple 1‑D crystal (a line of repeating “cells” like in Figure 1(a)). Its energy levels \\(E\\) depend on a wavelike parameter \\(k\\) (momentum). An 1‑D non‑Hermitian system is a tight‑binding chain whose effective Hamiltonian \\(H\\) is not equal to its adjoint (\\(H \\neq H^{\\dagger}\\)), e.g., due to asymmetric couplings, gain/loss, or non‑reciprocal driving. Consequently, eigenenergies are generally complex (\\(E \\in \\mathbb{C}\\)) and right/left eigenvectors differ (biorthogonality).\nIn such one‑dimensional non‑Hermitian systems with a point gap, under periodic boundaries PBC (“a loop”), energies trace closed loops as \\(k\\) runs from \\(0\\) to \\(2\\pi\\).\nUnder open boundaries OBC (“a finite chain”), something shocking can happen in non‑Hermitian systems (with loss/gain or non‑reciprocal couplings): the eigen‑energies collapse into arcs and loops assembled into a planar spectral graph embedded in the complex plane. Geometrically, OBC energies lie on intersection lines of inverse‑skin‑depth surfaces \\(\\mathrm{Im}\\,k=-\\log|z|\\) solely defined by \\(P(z,E)=0\\): the intersection of two such surfaces produces an edge, and the intersection of three or more surfaces produces a vertex. To simply put, connect those arcs/loops and you get a spectral graph."
  },
  {
    "objectID": "prototype_book.html#sec-quick-start",
    "href": "prototype_book.html#sec-quick-start",
    "title": "Spectral Graphs & Poly2Graph — A Hands‑On Tutorial",
    "section": "4 A quick start: One‑band example",
    "text": "4 A quick start: One‑band example\nWe’ll start from a simple one‑band characteristic polynomial and obtain its spectral graph.\nCharacteristic polynomial\n\\(P(z,E) = z^4 - z^2 - z^{-1} - E\\) (This corresponds to a scalar Bloch Hamiltonian \\(h(z)=z^4-z^2-z^{-1}\\), with \\(z=e^{ik}\\)).\n\n# If running on devices without essential libraries, uncomment the next line:\n# !pip install -U poly2graph sympy networkx matplotlib\n\nimport sympy as sp\nimport numpy as np\nnp.set_printoptions(threshold=20)\nimport matplotlib.pyplot as plt\nimport matplotlib.colors as colors\nimport networkx as nx\n\n# Poly2Graph (must be installed in your environment)\n# If this import fails, run the pip command above.\nimport poly2graph as p2g\n\n\n# For better plotly rendering in Jupyter environments\nimport plotly.io as pio\npio.renderers.default = \"plotly_mimetype+notebook_connected\"\n\nPlease ensure your version of Python &gt;= 3.11 , you can check the installation:\n\nprint(\"Poly2Graph version:\", p2g.__version__)\n\nPoly2Graph version: 0.2.0\n\n\n\n# Always remember to define common symbols first\nk = sp.symbols('k', real=True)\nz, E = sp.symbols('z E', complex=True)\n\nThe valid input formats to initialize a p2g.SpectralGraph object are:\n\nCharacteristic polynomial in terms of z and E:\n\nas a string of the Poly in terms of z and E\nas a sympy’s Poly (sympy.polys.polytools.Poly) with {z, 1/z, E} as generators\n\nBloch Hamiltonian in terms of k or z\n\nas a sympy Matrix in terms of k\nas a sympy Matrix in terms of z\n\n\nAll the following characteristics are valid and will initialize to the same characteristic polynomial and therefore produce the same spectral graph\n\nchar_poly_str = '-z**-1 - E - z**2 + z**4'\n\nchar_poly_Poly = sp.Poly(\n    -z**-1 - E - z**2 + z**4,\n    z, 1/z, E # generators are z, 1/z, E\n)\n\nphase_k = sp.exp(sp.I*k)\nchar_hamil_k = sp.Matrix([-phase_k**-1 - phase_k**2 + phase_k**4])\n\nchar_hamil_z = sp.Matrix([-z**-1 - E - z**2 + z**4])\n\nHere we use the string format as the initialization example.\n\nsg = p2g.SpectralGraph(char_poly_str, k=k, z=z, E=E)\n\n\n# print the number of energy bands\nprint('Bands:', sg.num_bands)\n\n# print the max hopping range (p,q)\nprint('Max hop (right):', sg.poly_p, 'Max hop (left):', sg.poly_q)\n\n# print the [Ereal_min,Ereal_max,Eimag_min,Eimag_max] window\nprint('Spectral window:', \n      dict(zip(['Re(E)_min', 'Re(E)_max', 'Im(E)_min', 'Im(E)_max'], \n               map(float, sg.spectral_square))))\n\nBands: 1\nMax hop (right): 1 Max hop (left): 4\nSpectral window: {'Re(E)_min': -2.3113904784272243, 'Re(E)_max': 1.6398687049402647, 'Im(E)_min': -1.9756295916837434, 'Im(E)_max': 1.9756295916837456}\n\n\nWe will see Poly2Graph automatically compute set of properties next:\n\nsg.ChP\n\n\\(\\displaystyle \\operatorname{Poly}{\\left( z^{4} - z^{2} - \\frac{1}{z} - E, z, \\frac{1}{z}, E, domain=\\mathbb{Z} \\right)}\\)\n\n\nBloch Hamiltonian:\n\nFor one-band model(The exponent of \\(E\\) is 1), it is a unique, \\(1 \\times 1\\) matrix (scalar).\n\n\nsg.h_k\n\n\\(\\displaystyle \\left[\\begin{matrix}e^{4 i k} - e^{2 i k} - e^{- i k}\\end{matrix}\\right]\\)\n\n\n\nor in \\(z\\) format(recall that \\(z = e^{ik}\\)).\n\n\nsg.h_z\n\n\\(\\displaystyle \\left[\\begin{matrix}- \\frac{- z^{5} + z^{3} + 1}{z}\\end{matrix}\\right]\\)\n\n\nFrobenius Companion Matrix of \\(P(z, E)\\):\n\nThe Frobenius companion matrix is a special matrix whose eigenvalues are exactly the roots of the characteristic polynomial \\(P(z, E)\\) for fixed \\(E\\).\nIn Poly2Graph, sg.companion_E gives this matrix (with \\(E\\) as a parameter, \\(z\\) as variable).\nPurpose:\n\nEfficiently computes all \\(z\\)-roots for any \\(E\\) using linear algebra (eigenvalues), instead of slow root-finding.\nThese \\(z\\)-roots are essential for calculating the spectral graph, GBZ, spectral potential, and density of states.\n\n\n\nsg.companion_E\n\n\\(\\displaystyle \\left[\\begin{matrix}0 & 0 & 0 & 0 & 1\\\\1 & 0 & 0 & 0 & E\\\\0 & 1 & 0 & 0 & 0\\\\0 & 0 & 1 & 0 & 1\\\\0 & 0 & 0 & 1 & 0\\end{matrix}\\right]\\)\n\n\nIt is a key tool for automating and accelerating spectral graph extraction in Poly2Graph.\n\n4.1 Spectral potential \\(\\Phi(E)\\), density of states \\(\\rho(E)\\), and skeleton\nWe compute \\(\\Phi(E)\\) and \\(\\rho(E)\\) on a grid of complex energies, then binarize \\(\\rho(E)\\) to get a skeleton. The phi and dos attributes store \\(\\Phi(E)\\) and \\(\\rho(E)\\) values on the grid, while skel is a boolean array indicating where \\(\\rho(E)\\) exceeds a threshold.\n\nphi, dos, skel = sg.spectral_images()\n\nfig, axes = plt.subplots(1, 3, figsize=(8, 3), sharex=True, sharey=True)\n\n# 1) Spectral potential\naxes[0].imshow(phi, extent=sg.spectral_square, origin='lower', cmap='terrain')\naxes[0].set(xlabel='Re(E)', ylabel='Im(E)', title='Spectral Potential')\n\n# 2) Density of States\npmin, pmax = np.percentile(dos, (0.1, 99.9))\n# Clip extreme DOS to increase visibility\nnorm = colors.Normalize(vmin=pmin, vmax=pmax)\naxes[1].imshow(dos, extent=sg.spectral_square, cmap='viridis', norm=norm)\naxes[1].set(xlabel='Re(E)', title='Density of States')\n\n# 3) Binarized skeleton\naxes[2].imshow(skel, extent=sg.spectral_square, cmap='gray')\naxes[2].set(xlabel='Re(E)', title='Graph Skeleton')\nplt.tight_layout()\nplt.savefig(\"assets/1-band-example_si.png\")\nplt.show()"
  },
  {
    "objectID": "prototype_book.html#sec-math-physics",
    "href": "prototype_book.html#sec-math-physics",
    "title": "Spectral Graphs & Poly2Graph — A Hands‑On Tutorial",
    "section": "5 Mathematics and Physics",
    "text": "5 Mathematics and Physics\nAlgebraic formulation:\nLet \\(H(z)\\) be the Bloch Hamiltonian with \\(z=e^{ik}\\) and \\[\nP(z,E)=\\det\\!\\big[H(z)-EI\\big]=\\sum_{n=-p}^{q} a_n(E)\\,z^n .\n\\] For a fixed \\(E\\), order the \\(z\\)‑roots of \\(P(z,E)=0\\) by magnitude \\(|\\beta_1(E)|\\le\\cdots\\le|\\beta_{p+q}(E)|\\). The generalized Brillouin zone (GBZ) is characterized by the equality \\[\n|\\beta_p(E)|=|\\beta_{p+1}(E)|,\n\\] and the corresponding loci of \\(E\\) form the OBC spectral graph. In particular, the density of states (DOS) in the continuum limit is supported only along these loci (as a singular distribution along curves, rather than an area region). In multi‑band systems there may also exist isolated edge modes outside the continuum spectral graph.\nPotential‑theoretic view:\nA convenient “spectral potential” (Ronkin function) can be defined from the \\(z\\)‑roots; one common choice (up to an additive constant and a sign convention) is \\[\n\\Phi(E)=-\\log|a_q(E)|-\\sum_{i=p+1}^{p+q}\\log|\\beta_i(E)|.\n\\] Its Laplacian yields the density of states(DOS), \\[\n\\rho(E)=-\\frac{1}{2\\pi}\\,\\nabla^2\\Phi(E),\n\\] where the sign depends on the convention used for \\(\\Phi\\). In the distributional sense, \\(\\rho(E)\\) has support only on the spectral graph. Equivalently, the spectral graph coincides with the ridges/troughs of \\(\\Phi(E)\\) (depending on the sign convention).\nIntuition: treat each eigenvalue \\(\\epsilon_n\\) as a tiny electric charge \\(\\rho(E) = \\lim_{N\\to\\infty}\\sum_n \\frac{1}{N} \\delta(E-\\epsilon_n)\\); while \\(\\Phi(E)\\) is an electrostatic‑like potential whose “ridges/troughs” trace the spectral graph; \\(\\rho(E)\\) is nonzero only on the graph. Please see the Section 12 below for a concrete illustration."
  },
  {
    "objectID": "prototype_book.html#sec-why-interesting",
    "href": "prototype_book.html#sec-why-interesting",
    "title": "Spectral Graphs & Poly2Graph — A Hands‑On Tutorial",
    "section": "6 Why interesting?",
    "text": "6 Why interesting?\nWithin Non‑Hermitian systems:\nNon-Hermitian spectra can realize many more graph connectivities than standard topological labels (like \\(\\mathbb{Z},\\mathbb{Z}_2\\)): stars, flowers, braids, etc., with novel transitions that change the number of endpoints/junctions/loops (no Hermitian analog). This is naturally expressed by writing dispersions as bivariate Laurent polynomials \\(P(E,z)\\) and studying how their imaginary‑momentum (“inverse skin depth”) surfaces intersect across the \\(E\\)‑plane.\nBeyond Hamiltonians (algebra‑to‑graph):\nSpectral graph is a general algebra-to-graph bridge. Because the equation \\(\\Phi(E) = - \\log|a_q(E)| - \\sum_{i=p+1}^{p+q}\\log|\\beta_i(E)|\\) uses only \\(P(E,z)\\), the construction extends to arbitrary Laurent polynomials, and via standard reductions to vectors and matrices. You get a universal topological fingerprint for many algebraic objects—making graph learning a front-door to problems in linear algebra, signal processing, photonics, circuits, and more.\nAutomation usage:\nThe Poly2Graph pipeline automates the construction above: it evaluates \\(z\\)‑roots via Frobenius companion eigen‑solvers with automatic backend detection (and optional GPU/TPU acceleration when TensorFlow or PyTorch is available), builds \\(\\Phi(E)\\) and \\(\\rho(E)\\) on an adaptive grid, and extracts a one‑pixel‑wide skeleton via morphological thinning to obtain a NetworkX MultiGraph with full edge geometry. In rare low‑DOS or long‑range multi‑band settings, local numerical instabilities can arise; Poly2Graph mitigates them with node‑merging and short‑edge contraction.\nExample. Here, we visualize a single-band example by an interactive 3D surface plot of \\(\\Phi(E)\\) along with the extracted skeleton Figure 1."
  },
  {
    "objectID": "prototype_book.html#sec-session-2",
    "href": "prototype_book.html#sec-session-2",
    "title": "Spectral Graphs & Poly2Graph — A Hands‑On Tutorial",
    "section": "7 What was hard before (and why we need Poly2Graph)?",
    "text": "7 What was hard before (and why we need Poly2Graph)?\nPrior to Poly2Graph, extracting spectral graphs was manual and fragile:\n\nYou had to scan parameters, plot large finite‑chain spectra, and visually infer the continuum graph.\nComputing the GBZ roots \\(\\beta_i(E)\\) for every sampled energy \\(E\\) is a bottleneck; naive solvers are slow and memory‑hungry.\nEven with a DOS image, turning that into a clean graph with correct endpoints, junctions, and loops requires careful morphology (thresholding, skeletonization, node/edge parsing).\n\nPoly2Graph lifts these barriers with an end‑to‑end, high‑performance pipeline:\n\nAccepts either \\(H(z)\\) (as a sympy.Matrix) or \\(P(z,E)\\) (string or sympy.Poly).\n\nComputes the spectral potential \\(\\Phi(E)\\) from \\(z\\)‑roots (fast eigen‑solvers on Frobenius companion matrices; optional GPU/TPU via TensorFlow/PyTorch).\n\nTakes the Laplacian to get DOS, then does adaptive, two‑stage refinement (coarse mask → high‑res on just ~1–5% of the region).\n\nApplies image morphology to extract a one‑pixel skeleton, then returns a NetworkX MultiGraph with full edge geometry (the sampled curve).\n\nThis automation has enabled HSG‑12M (11.6M static + 5.1M temporal spectral multigraphs), demonstrating scale and diversity previously out of reach (Learn more from HSG-12M: A Large-Scale Spatial Multigraph Dataset if interested)."
  },
  {
    "objectID": "prototype_book.html#sec-spectral-graph",
    "href": "prototype_book.html#sec-spectral-graph",
    "title": "Spectral Graphs & Poly2Graph — A Hands‑On Tutorial",
    "section": "8 Extract the spectral graph",
    "text": "8 Extract the spectral graph\nContinue with the quick start part, we visualize these results by an interactive 3D surface plot of \\(\\Phi(E)\\). Feel free to rotate/zoom the plot to examine the surface and skeleton from different angles.\n\nimport plotly.graph_objects as go\n\nE_re = np.linspace(*sg.spectral_square[:2], phi.shape[0])\nE_im = np.linspace(*sg.spectral_square[2:], phi.shape[1])\nfig = go.Figure(data=[go.Surface(z=phi, x=E_re, y=E_im, \n            opacity=0.6, colorscale='Spectral_r')])\nfig.update_layout(\nscene=dict(\n    aspectratio=dict(x=1.5, y=1, z=.8),\n    xaxis_title='Re(E)',yaxis_title='Im(E)',zaxis_title='Phi(E)',\n),\ntitle='3D Surface Plot of Spectral Potential',\nwidth=700, height=600\n)\nfig.show()\n\n\n\n                            \n                                            \n\n\nFigure 1\n\n\n\n\nsg.spectral_graph() returns a NetworkX MultiGraph with node positions and polyline geometry along each edge.\n\n# Draw the multi-band spectral graph\nG = sg.spectral_graph()\npos2 = nx.get_node_attributes(G, 'pos')\nplt.figure()\nnx.draw_networkx_nodes(G, pos2, node_size=20)\nnx.draw_networkx_edges(G, pos2)\nplt.axis('equal'); plt.title('Spectral Graph (1-band)')\nplt.show()\n\nprint(f'#nodes: {G.number_of_nodes()}  #edges: {G.number_of_edges()}')\n\n# Show attributes of a node and an edge\nany_node = list(G.nodes(data=True))[0]\nprint('A node has attributes:', list(any_node[1].keys()))\nany_edge = list(G.edges(keys=True, data=True))[0]\nprint('An edge has attributes:', list(any_edge[3].keys()))\n\n\n\n\n\n\n\n\n#nodes: 7  #edges: 6\nA node has attributes: ['pos', 'dos', 'potential']\nAn edge has attributes: ['weight', 'pts', 'avg_dos', 'avg_potential']\n\n\nAs you can see above, the spectral graph is a networkx.MultiGraph object.\n\nNode Attributes\n\npos : (2,)-numpy array\n\nthe position of the node \\((\\text{Re}(E), \\text{Im}(E))\\)\n\ndos : float\n\nthe density of states at the node\n\npotential : float\n\nthe spectral potential at the node\n\n\nEdge Attributes\n\nweight : float\n\nthe weight of the edge, which is the length of the edge in the complex energy plane\n\npts : (w, 2)-numpy array\n\nthe positions of the points constituting the edge, where w is the number of points along the edge, i.e., the length of the edge, equals weight\n\navg_dos : float\n\nthe average density of states along the edge\n\navg_potential : float\n\nthe average spectral potential along the edge\n\n\n\n\nnode_attr = dict(G.nodes(data=True))\nedge_attr = list(G.edges(data=True))\nprint('The attributes of the first node\\n', node_attr[0], '\\n')\nprint('The attributes of the first edge\\n', edge_attr[0][-1], '\\n')\n\nThe attributes of the first node\n {'pos': array([0.88936098, 1.90810319]), 'dos': np.float32(0.25110298), 'potential': np.float32(-0.4699422)} \n\nThe attributes of the first edge\n {'weight': np.float64(2.0950480742544872), 'pts': array([[0.88550233, 1.89652723],\n       [0.88550233, 1.89266858],\n       [0.88550233, 1.88880993],\n       ...,\n       [0.81990525, 0.01350528],\n       [0.8237639 , 0.00964663],\n       [0.8237639 , 0.00192933]]), 'avg_dos': np.float32(0.079228334), 'avg_potential': np.float32(-0.2639912)}"
  },
  {
    "objectID": "prototype_book.html#2-sec-multi-band",
    "href": "prototype_book.html#2-sec-multi-band",
    "title": "Spectral Graphs & Poly2Graph — A Hands‑On Tutorial",
    "section": "9 A multi‑band example",
    "text": "9 A multi‑band example\nNow consider a four‑band polynomial:\n\\[\nP(z,E) = z^2 + z^{-2} + E z - E^4\n\\]\nA possible Bloch Hamiltonian realization is: \\[\\textbf{h}(z)=\\begin{pmatrix}\n0 & 0 & 0 & z^2 + 1/z^2 \\\\\n1 & 0 & 0 & z \\\\\n0 & 1 & 0 & 0 \\\\\n0 & 0 & 1 & 0 \\\\\n\\end{pmatrix}\\] Poly2Graph can work directly from the string/sympy.Poly as shown below.\n\n# We start with a polynomial string\nsg_multi = p2g.SpectralGraph(\"z**2 + 1/z**2 + E*z - E**4\", k, z, E)\n\n\n# print the number of energy bands\nprint('Bands:', sg_multi.num_bands)\n\n# print the max hopping range (p,q)\nprint('Max hop (right):', sg_multi.poly_p, 'Max hop (left):', sg_multi.poly_q)\n\n# print the [Ereal_min,Ereal_max,Eimag_min,Eimag_max] window\nprint('Spectral window:', \n      dict(zip(['Re(E)_min', 'Re(E)_max', 'Im(E)_min', 'Im(E)_max'], \n               map(float, sg_multi.spectral_square))))\n\nBands: 4\nMax hop (right): 2 Max hop (left): 2\nSpectral window: {'Re(E)_min': -1.4055954628228848, 'Re(E)_max': 1.4055954628228862, 'Im(E)_min': -1.4055954628228862, 'Im(E)_max': 1.4055954628228848}\n\n\n\nsg_multi.ChP\n\n\\(\\displaystyle \\operatorname{Poly}{\\left( z^{2} + zE + \\frac{1}{z^{2}} - E^{4}, z, \\frac{1}{z}, E, domain=\\mathbb{Z} \\right)}\\)\n\n\n\nsg_multi.h_k\n\n\\(\\displaystyle \\left[\\begin{matrix}0 & 0 & 0 & e^{2 i k} + e^{- 2 i k}\\\\1 & 0 & 0 & e^{i k}\\\\0 & 1 & 0 & 0\\\\0 & 0 & 1 & 0\\end{matrix}\\right]\\)\n\n\n\nsg_multi.h_z\n\n\\(\\displaystyle \\left[\\begin{matrix}0 & 0 & 0 & z^{2} + \\frac{1}{z^{2}}\\\\1 & 0 & 0 & z\\\\0 & 1 & 0 & 0\\\\0 & 0 & 1 & 0\\end{matrix}\\right]\\)\n\n\n\nsg_multi.companion_E\n\n\\(\\displaystyle \\left[\\begin{matrix}0 & 0 & 0 & -1\\\\1 & 0 & 0 & 0\\\\0 & 1 & 0 & E^{4}\\\\0 & 0 & 1 & - E\\end{matrix}\\right]\\)\n\n\n\n9.1 Spectral potential \\(\\Phi(E)\\), density of states \\(\\rho(E)\\), and skeleton\nLike the one-band example, we also compute \\(\\Phi(E)\\) and \\(\\rho(E)\\) on a grid of complex energies, then binarize \\(\\rho(E)\\) to get a skeleton.\n\nphi2, dos2, skel2 = sg_multi.spectral_images()\n\nfig, axes = plt.subplots(1, 3, figsize=(8, 3), sharex=True, sharey=True)\n\n# 1) Spectral potential\naxes[0].imshow(phi2, extent=sg.spectral_square, origin='lower', cmap='terrain')\naxes[0].set(xlabel='Re(E)', ylabel='Im(E)', title='Spectral Potential')\n\n# 2) Density of States\npmin, pmax = np.percentile(dos, (0.1, 99.9))\n# Clip extreme DOS to increase visibility\nnorm = colors.Normalize(vmin=pmin, vmax=pmax)\naxes[1].imshow(dos2, extent=sg.spectral_square, cmap='viridis', norm=norm)\naxes[1].set(xlabel='Re(E)', title='Density of States')\n\n# 3) Binarized skeleton\naxes[2].imshow(skel2, extent=sg.spectral_square, cmap='gray')\naxes[2].set(xlabel='Re(E)', title='Graph Skeleton')\nplt.tight_layout()\nplt.savefig(\"assets/multi-band-example_si.png\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n9.2 Extract the spectral graph\n\n# Draw the multi-band spectral graph\nG2 = sg_multi.spectral_graph()\npos2 = nx.get_node_attributes(G2, 'pos')\nplt.figure()\nnx.draw_networkx_nodes(G2, pos2, node_size=20)\nnx.draw_networkx_edges(G2, pos2)\nplt.axis('equal'); plt.title('Spectral Graph (multi‑band)')\nplt.show()\n\nprint(f'#nodes: {G2.number_of_nodes()}  #edges: {G2.number_of_edges()}')\n\n# Show attributes of a node and an edge\nany_node = list(G2.nodes(data=True))[0]\nprint('A node has attributes:', list(any_node[1].keys()))\nany_edge = list(G2.edges(keys=True, data=True))[0]\nprint('An edge has attributes:', list(any_edge[3].keys()))\n\n\n\n\n\n\n\n\n#nodes: 21  #edges: 18\nA node has attributes: ['pos', 'dos', 'potential']\nAn edge has attributes: ['weight', 'pts', 'avg_dos', 'avg_potential']"
  },
  {
    "objectID": "prototype_book.html#3-ChP-class",
    "href": "prototype_book.html#3-ChP-class",
    "title": "Spectral Graphs & Poly2Graph — A Hands‑On Tutorial",
    "section": "10 Characteristic Polynomial Class (p2g.CharPolyClass)",
    "text": "10 Characteristic Polynomial Class (p2g.CharPolyClass)\nFor scanning families of polynomials (e.g., varying two complex coefficients across a grid), use p2g.CharPolyClass. This class parallelizes evaluation and is designed to generate many graphs efficiently (e.g., to reproduce temporal sequences as in T‑HSG‑5M).\nTo be specific, p2g.CharPolyClass is:\n\nA class of parametrized non-Hermitian lattices\nGenerate spectral properties, including spectral graph in parallel\nOptimized for computational efficiency and numerical stability\n\nLet us add two parameters {a,b} to the aforementioned multi-band example and construct a p2g.CharPolyClass object.\n\na, b = sp.symbols('a b', real=True)\n\ncp = p2g.CharPolyClass(\n    \"z**2 + a/z**2 + b*E*z - E**4\", \n    k=k, z=z, E=E,\n    params={a, b}, # pass parameters as a set\n)\n\nDerived Bloch Hamiltonian `h_z` with 4 bands.\n\n\nJust like the examples above, we can also check the automatically computed properties:\n\ncp.ChP\n\n\\(\\displaystyle \\operatorname{Poly}{\\left( z^{2} + b zE + a \\frac{1}{z^{2}} - E^{4}, z, \\frac{1}{z}, E, domain=\\mathbb{Z}\\left[a, b\\right] \\right)}\\)\n\n\n\ncp.h_k\n\n\\(\\displaystyle \\left[\\begin{matrix}0 & 0 & 0 & a e^{- 2 i k} + e^{2 i k}\\\\1 & 0 & 0 & b e^{i k}\\\\0 & 1 & 0 & 0\\\\0 & 0 & 1 & 0\\end{matrix}\\right]\\)\n\n\n\ncp.h_z\n\n\\(\\displaystyle \\left[\\begin{matrix}0 & 0 & 0 & \\frac{a}{z^{2}} + z^{2}\\\\1 & 0 & 0 & b z\\\\0 & 1 & 0 & 0\\\\0 & 0 & 1 & 0\\end{matrix}\\right]\\)\n\n\n\ncp.companion_E\n\n\\(\\displaystyle \\left[\\begin{matrix}0 & 0 & 0 & - a\\\\1 & 0 & 0 & 0\\\\0 & 1 & 0 & E^{4}\\\\0 & 0 & 1 & - E b\\end{matrix}\\right]\\)\n\n\nTo get an array of spectral images or spectral graphs, we first prepare the values of the parameters {a,b}\n\na_array = np.linspace(-2, 2, 6)\nb_array = np.linspace(-1, 1, 6)\na_grid, b_grid = np.meshgrid(a_array, b_array)\nparam_dict = {a: a_grid, b: b_grid}\nprint('a_grid shape:', a_grid.shape,\n    '\\nb_grid shape:', b_grid.shape)\n\na_grid shape: (6, 6) \nb_grid shape: (6, 6)\n\n\nYou can check the grid generated to ensure your parameters\n\na_grid, b_grid\n\n(array([[-2. , -1.2, -0.4,  0.4,  1.2,  2. ],\n        [-2. , -1.2, -0.4,  0.4,  1.2,  2. ],\n        [-2. , -1.2, -0.4,  0.4,  1.2,  2. ],\n        [-2. , -1.2, -0.4,  0.4,  1.2,  2. ],\n        [-2. , -1.2, -0.4,  0.4,  1.2,  2. ],\n        [-2. , -1.2, -0.4,  0.4,  1.2,  2. ]]),\n array([[-1. , -1. , -1. , -1. , -1. , -1. ],\n        [-0.6, -0.6, -0.6, -0.6, -0.6, -0.6],\n        [-0.2, -0.2, -0.2, -0.2, -0.2, -0.2],\n        [ 0.2,  0.2,  0.2,  0.2,  0.2,  0.2],\n        [ 0.6,  0.6,  0.6,  0.6,  0.6,  0.6],\n        [ 1. ,  1. ,  1. ,  1. ,  1. ,  1. ]]))\n\n\nNote that the value array of the parameters should have the same shape, which is also the shape of the output array of spectral images.\n\nphi_arr, dos_arr, binarized_dos_arr, spectral_square = \\\n    cp.spectral_images(param_dict=param_dict, device='/cpu:0')\nprint('phi_arr shape:', phi_arr.shape,\n    '\\ndos_arr shape:', dos_arr.shape,\n    '\\nbinarized_dos_arr shape:', binarized_dos_arr.shape)\n\nphi_arr shape: (6, 6, 1024, 1024) \ndos_arr shape: (6, 6, 1024, 1024) \nbinarized_dos_arr shape: (6, 6, 1024, 1024)\n\n\n\nphi_arr[:, :, 0, 0]\n\narray([[-2.79088283, -2.56152201, -2.07190657, -2.33312154, -2.826159  ,\n        -3.05699062],\n       [-2.61931658, -2.3819747 , -1.87466085, -2.14679098, -2.65622234,\n        -2.89444447],\n       [-2.42141795, -2.17299414, -1.64018846, -1.92253423, -2.45588088,\n        -2.70452452],\n       [-2.42141819, -2.17299461, -1.64018691, -1.92253542, -2.45588088,\n        -2.70452452],\n       [-2.61931658, -2.3819747 , -1.87466145, -2.14679122, -2.65622234,\n        -2.8944447 ],\n       [-2.79088283, -2.56152201, -2.07190657, -2.33312154, -2.82615995,\n        -3.05699062]])\n\n\nphi_arr, dos_arr, and binarized_dos_arr are arrays computed by cp.spectral_images(), representing different spectral quantities:\n\nphi_arr: The array of spectral potential values, i.e., \\(\\Phi(E)\\), for each parameter point((a,b), here \\(6*6\\)) and energy grid(each small sampling grid on the complex \\(E\\) plain, here \\(1024*1024\\)). It describes the “potential landscape” over the complex energy plane, with its ridges tracing the spectral graph.\ndos_arr: The array of density of states values, i.e., \\(\\rho(E)\\), for each parameter point and energy grid. It is significant only on the spectral graph (where the spectral condition is met), and nearly zero elsewhere.\nbinarized_dos_arr: The binarized density of states array, obtained by thresholding \\(\\rho(E)\\), which extracts the skeleton (the graph structure) for further analysis.\n\nThese arrays typically have shapes like (number of parameter points, ..., H, W), where \\(H\\) and \\(W\\) are the height and width of the energy grid. Each parameter point corresponds to one spectral potential/density/skeleton image.\n\nfrom mpl_toolkits.axes_grid1 import ImageGrid\n\nfig = plt.figure(figsize=(13, 13))\ngrid = ImageGrid(fig, 111, nrows_ncols=(6, 6), axes_pad=0, \n                 label_mode='L', share_all=True)\n\nfor ax, (i, j) in zip(grid, [(i, j) for i in range(6) for j in range(6)]):\n    ax.imshow(phi_arr[i, j], extent=spectral_square[i, j], cmap='Spectral_r')\n    ax.set(xlabel='Re(E)', ylabel='Im(E)')\n    ax.text(\n        0.03, 0.97, f'a = {a_array[i]:.2f}, b = {b_array[j]:.2f}',\n        ha='left', va='top', transform=ax.transAxes,\n        fontsize=10, color='tab:red',\n        bbox=dict(alpha=0.8, facecolor='white')\n    )\n\nplt.savefig(\"assets/ChP-example_si.png\")\nplt.show()"
  },
  {
    "objectID": "prototype_book.html#sec-gallery-example",
    "href": "prototype_book.html#sec-gallery-example",
    "title": "Spectral Graphs & Poly2Graph — A Hands‑On Tutorial",
    "section": "11 Example: Reproducing gallery figure with p2g.CharPolyClass in “Zoology of non-Hermitian spectra and their graph topology”",
    "text": "11 Example: Reproducing gallery figure with p2g.CharPolyClass in “Zoology of non-Hermitian spectra and their graph topology”\nAbove we tried to use p2g.CharPolyClass to construct a characteristic polynomial class \\(z^2 + az^-2 + bEz - E^4\\), which is an interesting while simple class. Now we can work on more challenging classes with both different coefficients and exponents.\n\n  Figure 2. OBC energy spectra of ChP\n\nThe figure above shows a larger class of characteristic polynomials from the paper “Zoology of non-Hermitian spectra and their graph topology”. Try to plot it yourself!\nHint: you can write 6 different p2g.CharPolyClass with the parameter \\(r\\) and plot them by column.\n\n# Figure S13 with 6 CharPolyClass \nimport numpy as np\nimport sympy as sp\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.axes_grid1 import ImageGrid\nimport poly2graph as p2g\n\n# Basic settings\nLAYER  = 'skeleton'    # 'skeleton' shows skeleton; 'potential' shows spectral potential\nDEVICE = '/cpu:0'      # Use '/gpu:0' if GPU is available\n\n# Row parameter r (in paper order)\nR_VALUES = np.array([-10, -2, -1, -0.5, 0.0, 0.5, 1.0, 2.0, 10.0], dtype=float)\nr_grid   = R_VALUES.reshape(-1, 1)  # (9,1)\n\n# Symbols \nk = sp.symbols('k', real=True)\nz, E = sp.symbols('z E', complex=True)\nr = sp.symbols('r', real=True)\n\n\n# 6 CharPolyClass (parameterized only by r)\n# Column order strictly follows the paper: [(1,2), (2,3), (1,3), (3,4), (2,4), (1,4)]\ncp12 = p2g.CharPolyClass(\"z**2 + 1/z + r*E**1*z - E**2\", k=k, z=z, E=E, params={r})  # (g,f)=(1,2)\ncp23 = p2g.CharPolyClass(\"z**2 + 1/z + r*E**2*z - E**3\", k=k, z=z, E=E, params={r})  # (2,3)\ncp13 = p2g.CharPolyClass(\"z**2 + 1/z + r*E**1*z - E**3\", k=k, z=z, E=E, params={r})  # (1,3)\ncp34 = p2g.CharPolyClass(\"z**2 + 1/z + r*E**3*z - E**4\", k=k, z=z, E=E, params={r})  # (3,4)\ncp24 = p2g.CharPolyClass(\"z**2 + 1/z + r*E**2*z - E**4\", k=k, z=z, E=E, params={r})  # (2,4)\ncp14 = p2g.CharPolyClass(\"z**2 + 1/z + r*E**1*z - E**4\", k=k, z=z, E=E, params={r})  # (1,4)\n\n# Compute each column at once (all shapes are (9,1,H,W) or (9,1,4)) \nphi12, dos12, bin12, ext12 = cp12.spectral_images(param_dict={r: r_grid}, device=DEVICE )\nphi23, dos23, bin23, ext23 = cp23.spectral_images(param_dict={r: r_grid}, device=DEVICE)\nphi13, dos13, bin13, ext13 = cp13.spectral_images(param_dict={r: r_grid}, device=DEVICE)\nphi34, dos34, bin34, ext34 = cp34.spectral_images(param_dict={r: r_grid}, device=DEVICE)\nphi24, dos24, bin24, ext24 = cp24.spectral_images(param_dict={r: r_grid}, device=DEVICE)\nphi14, dos14, bin14, ext14 = cp14.spectral_images(param_dict={r: r_grid}, device=DEVICE)\n\n# Concatenate all columns in paper order (9,6,H,W) \nphi_all = np.concatenate([phi12[:, :1], phi23[:, :1], phi13[:, :1],\n                          phi34[:, :1], phi24[:, :1], phi14[:, :1]], axis=1)\ndos_all = np.concatenate([dos12[:, :1], dos23[:, :1], dos13[:, :1],\n                          dos34[:, :1], dos24[:, :1], dos14[:, :1]], axis=1)\nbin_all = np.concatenate([bin12[:, :1], bin23[:, :1], bin13[:, :1],\n                          bin34[:, :1], bin24[:, :1], bin14[:, :1]], axis=1)\next_all = np.concatenate([ext12[:, :1], ext23[:, :1], ext13[:, :1],\n                          ext34[:, :1], ext24[:, :1], ext14[:, :1]], axis=1)  # (9,6,4)\n\nGF_LIST = [(1,2), (2,3), (1,3), (3,4), (2,4), (1,4)]  # For titles\n\nDerived Bloch Hamiltonian `h_z` with 2 bands.\nDerived Bloch Hamiltonian `h_z` with 3 bands.\nDerived Bloch Hamiltonian `h_z` with 3 bands.\nDerived Bloch Hamiltonian `h_z` with 4 bands.\nDerived Bloch Hamiltonian `h_z` with 4 bands.\nDerived Bloch Hamiltonian `h_z` with 4 bands.\n\n\n\nfig = plt.figure(figsize=(13, 13))\ngrid = ImageGrid(fig, 111, nrows_ncols=(9, 6), axes_pad=0.1, \n                 label_mode='L', share_all=True)\n\n# Unified coordinate range\nuniform_extent = [-2, 2, -2, 2]  # [left, right, bottom, top]\n\nfor ax, (i, j) in zip(grid, [(i, j) for i in range(9) for j in range(6)]):\n    # Use unified extent\n    pmin, pmax = np.percentile(dos_all[i, j], (0.5, 99.5))\n    # Clip extreme DOS to increase visibility\n    norm = colors.Normalize(vmin=pmin, vmax=pmax)\n    ax.imshow(dos_all[i, j], extent=uniform_extent, cmap='viridis', norm=norm)\n    ax.set(xlabel='Re(E)', ylabel='Im(E)')\n    ax.set_aspect('equal', adjustable='box')\n    \n    g, f = GF_LIST[j]\n\n    plt.setp(ax.spines.values(), linewidth=1.5, color='white')\n\nplt.savefig(\"assets/6-ChP_grid.png\")\nplt.show()"
  },
  {
    "objectID": "prototype_book.html#sec-ssh-example",
    "href": "prototype_book.html#sec-ssh-example",
    "title": "Spectral Graphs & Poly2Graph — A Hands‑On Tutorial",
    "section": "12 SSH example",
    "text": "12 SSH example\nConsider a SSH(Su–Schrieffer–Heeger) chain, which is an extremely important model for studying the fundamental properties of one-dimensional topological insulators.\n\n  Figure 3. SSH chain with alternating hopping strengths\n\nHere solid and dashed lines in the figure mean different hopping strengths. To simplify the problem, the hopping range is limited to one.\nThe Bloch Hamiltonian reads \\(H(z)=\n\\begin{pmatrix}\n0 & t_1+t_2 z \\\\\nt_1+t_2 z^{-1} & 0\n\\end{pmatrix},\n\\qquad  z=e^{ik}.\\) In real space this corresponds to a bipartite lattice where intracell and intercell hoppings alternate along the chain.\nTaking the determinant yields the characteristic polynomial \\(P(z,E) \\\\= \\det[H(z)-EI]\n    =E^{2}-(t_1+t_2 z)(t_1+t_2 z^{-1}) \\\\\n    =E^{2}-(t_1^2+t_2^2+t_1 t_2(z+z^{-1})).\\)\nWe can obtain the \\(z(E)\\) using Schrödinger Equation \\(H\\psi = E\\psi\\): \\(z_{\\pm}(E)\n=\\frac{\\,E^2 - t_1^2 - t_2^2 \\,\\pm\\,\n\\sqrt{(E^2 - t_1^2 - t_2^2)^2 - 4\\,t_1^2 t_2^2}\\,}\n{\\,2 t_1 t_2\\,}.\\) here \\(z(E)\\) and \\(\\beta (E)\\) are the same with different mathematical symbols.\nDue to the 2 energy band of SSH model, we notice that \\(|\\beta_p(E)|=|\\beta_{p+1}(E)|\\) present as \\(z_{-}(E) = z_{+}(E)\\), thus we can define the GBZ of SSH model.\nUsing the equations mentioned above Section 5 , we can also try to obtain the \\(\\Phi(E)\\) and \\(\\rho(E)\\) ourselves.\nYou can check your answer with mine:\n\\(\\Phi(E) = - log|t_{1}t_{2}| - log|z_{+}(E)|\\), \\(\\rho(E) =  \\frac{1}{2\\pi}\\nabla^2 log|z_{+}(E)|.\\)\nNext, we can use Poly2Graph to check the properties of SSH model and visualize the spectral graph of it. If you are confused about the code, please refer to the previous examples Section 4.\n\n# Always remember to define common symbols first\nk = sp.symbols('k', real=True)\nz, E = sp.symbols('z E', complex=True)\n\nHere we use the string format as the initialization example.\n\n# here t1, t2 = 1, 1, using P(z,E) = E^2 - (1 + z)(-1 + z^-1)\nchar_poly_str_ssh = 'E**2 + z - z**-1'\n\n\nsg_ssh = p2g.SpectralGraph(char_poly_str_ssh, k=k, z=z, E=E)\n\n\n# print the number of energy bands\nprint('Bands:', sg_ssh.num_bands)\n\n# print the max hopping range (p,q)\nprint('Max hop (right):', sg_ssh.poly_p, 'Max hop (left):', sg_ssh.poly_q)\n\n# print the [Ereal_min,Ereal_max,Eimag_min,Eimag_max] window\nprint('Spectral window:', \n      dict(zip(['Re(E)_min', 'Re(E)_max', 'Im(E)_min', 'Im(E)_max'], \n               map(float, sg_ssh.spectral_square))))\n\nBands: 2\nMax hop (right): 1 Max hop (left): 1\nSpectral window: {'Re(E)_min': -1.0484584139607451, 'Re(E)_max': 1.048458413960742, 'Im(E)_min': -1.0484584139607425, 'Im(E)_max': 1.0484584139607447}\n\n\n\nsg_ssh.ChP\n\n\\(\\displaystyle \\operatorname{Poly}{\\left( z - \\frac{1}{z} + E^{2}, z, \\frac{1}{z}, E, domain=\\mathbb{Z} \\right)}\\)\n\n\n\nsg_ssh.h_z\n\n\\(\\displaystyle \\left[\\begin{matrix}0 & - z + \\frac{1}{z}\\\\1 & 0\\end{matrix}\\right]\\)\n\n\n\nsg_ssh.companion_E\n\n\\(\\displaystyle \\left[\\begin{matrix}0 & 1\\\\1 & - E^{2}\\end{matrix}\\right]\\)\n\n\n\nphi, dos, skel = sg_ssh.spectral_images()\n\nfig, axes = plt.subplots(1, 3, figsize=(8, 3), sharex=True, sharey=True)\n\n# 1) Spectral potential\naxes[0].imshow(phi, extent=sg.spectral_square, origin='lower', cmap='terrain')\naxes[0].set(xlabel='Re(E)', ylabel='Im(E)', title='Spectral Potential')\n\n# 2) Density of States\npmin, pmax = np.percentile(dos, (0.1, 99.9))\n# Clip extreme DOS to increase visibility\nnorm = colors.Normalize(vmin=pmin, vmax=pmax)\naxes[1].imshow(dos, extent=sg.spectral_square, cmap='viridis', norm=norm)\naxes[1].set(xlabel='Re(E)', title='Density of States')\n\n# 3) Binarized skeleton\naxes[2].imshow(skel, extent=sg.spectral_square, cmap='gray')\naxes[2].set(xlabel='Re(E)', title='Graph Skeleton')\nplt.tight_layout()\nplt.savefig(\"assets/ssh-example_si.png\")\nplt.show()"
  }
]